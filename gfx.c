/**********************************************************************************************************************
 * \file gfx.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "gfx.h"
#include <stdio.h>

/* PDL and board */
#include "cy_pdl.h"
#include "cybsp.h"

/* Graphics Driver */
#include "cygfx_driver_api.h"

/* Util library */
#include "cygfx_window.h"
#include "sm_util.h"
#include "ut_compatibility.h"
#include "ut_disp.h"
#include "ut_disp_panels.h"
#include "ut_memman.h"

/* This include contains all matrix related definitions */
#include "pe_matrix.h"

#include "res.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define DISPLAY_WIDTH           (800)
#define DISPLAY_HEIGHT          (480)

#define WINDOW_WIDTH            (800)
#define WINDOW_HEIGHT           (480)

#define TASK_INSTR_BUFFER_SIZE  (16 * 1024)

#define STATE_COUNT             (5)

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/
typedef struct
{
    CYGFX_WINDOW            win;
    CYGFX_SURFACE           surfFramebuffer[2];
    CYGFX_SYNC_OBJECT_S     sync;
    CYGFX_U08               id;
} DoubleBufferedWindow;

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
static CYGFX_DISP disp;
static CYGFX_BE_CONTEXT ctx;
static void* taskInstrBuffer;
static DoubleBufferedWindow db;
static CYGFX_SURFACE surfIfx;
static CYGFX_U08 state = 0;

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
static void initVideoSSInterrupts(void);
static CYGFX_ERROR initDriverAndDisplay(void);
static CYGFX_ERROR initContext(void);
static CYGFX_ERROR initTaskInstrBuffer(void);
static CYGFX_ERROR initSync(void);
static CYGFX_ERROR initSurfaces(void);
static CYGFX_ERROR initWindows(void);

static CYGFX_ERROR clearWindow(void);
static CYGFX_ERROR renderTranslateScene(void);
static CYGFX_ERROR renderScaleScene(void);
static CYGFX_ERROR renderRotateScene(void);
static CYGFX_ERROR renderShearScene(void);
static CYGFX_ERROR renderPerspectiveScene(void);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/**********************************************************************************************************************
 * Function Name: initGfx
 * Summary:
 *  Initializes all required subsystems
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
CYGFX_ERROR initGfx(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    initVideoSSInterrupts();
    UTIL_SUCCESS(ret, initDriverAndDisplay());
    UTIL_SUCCESS(ret, initContext());
    UTIL_SUCCESS(ret, initTaskInstrBuffer());
    UTIL_SUCCESS(ret, initSync());
    UTIL_SUCCESS(ret, initSurfaces());
    UTIL_SUCCESS(ret, initWindows());
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: loopGfx
 * Summary:
 *  Main graphics application. Needs to be called periodically in a loop, at least
 *  as often as the target framerate (for example for 60 FPS -> 1/60 secs = ~16.66 ms).
 *  Can be called quicker, function takes care of syncing and will immediately return
 *  if not ready yet. 
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
CYGFX_ERROR loopGfx(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    /* Was the last frame rendered yet? */
    if (CyGfx_SyncWaitSync(&db.sync, 0) == CYGFX_ERP_ERR_SYNC_TIMEOUT)
    {
        /* We return okay because it's normal for this function to return early if previous frame not finished yet */
        return CYGFX_OK;
    }

    /* Bind new buffer */
    UTIL_SUCCESS(ret, CyGfx_BeBindSurface(ctx, CYGFX_BE_TARGET_STORE | CYGFX_BE_TARGET_DST,
         db.surfFramebuffer[db.id]));
    
    /* Fill the window with a constant color */
    UTIL_SUCCESS(ret, clearWindow());
    
    /* Dependent on state, render a different scene */
    switch (state)
    {
        case 0: UTIL_SUCCESS(ret, renderTranslateScene()); break;
        case 1: UTIL_SUCCESS(ret, renderScaleScene()); break;
        case 2: UTIL_SUCCESS(ret, renderRotateScene()); break;
        case 3: UTIL_SUCCESS(ret, renderShearScene()); break;
        case 4: UTIL_SUCCESS(ret, renderPerspectiveScene()); break;
        default: UTIL_SUCCESS(ret, renderTranslateScene()); break;
    }
    
    /* Sync the blit engine to the window. Get a sync object in the end which indicates when frame is finished
     * and this function can be executed again */
    UTIL_SUCCESS(ret, CyGfx_BeGetSync(ctx, &db.sync));
    UTIL_SUCCESS(ret, CyGfx_WinWaitSync(db.win, &db.sync));
    UTIL_SUCCESS(ret, CyGfx_WinSetSurface(db.win, CYGFX_DISP_BUFF_TARGET_COLOR_BUFF, db.surfFramebuffer[db.id]));
    UTIL_SUCCESS(ret, CyGfx_WinCommit(db.win));
    UTIL_SUCCESS(ret, CyGfx_WinGetSync(db.win, &db.sync));
    
    /* Swap framebuffers */
    db.id = (db.id == 0) ? 1 : 0;
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: deinitGfx
 * Summary:
 *  Deinitializes subsystems and frees memory.
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
CYGFX_ERROR deinitGfx(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    /* Windows */
    UTIL_SUCCESS(ret, CyGfx_WinDestroy(db.win));
    
    /* Surfaces */
    utSurfDeleteBuffer(surfIfx);
    UTIL_SUCCESS(ret, utSmDeleteSurfaceObjects(1, &surfIfx));
    utSurfDeleteBuffer(db.surfFramebuffer[1]);
    UTIL_SUCCESS(ret, utSmDeleteSurfaceObjects(1, &db.surfFramebuffer[1]));
    utSurfDeleteBuffer(db.surfFramebuffer[0]);
    UTIL_SUCCESS(ret, utSmDeleteSurfaceObjects(1, &db.surfFramebuffer[0]));
    
    /* Task instruction buffers */
    utVideoFree(taskInstrBuffer);
    
    /* Contexts */
    utPeDeleteContext(ctx);
    
    /* Display */
    UTIL_SUCCESS(ret, CyGfx_DispCloseDisplay(disp));
    
    /* Driver */
    UTIL_SUCCESS(ret, CyGfx_SysDeInitializeDriver());
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: changeNextScene
 * Summary:
 *  Switches to next scene to be rendered.
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
void changeNextScene(void)
{
    state = (state < STATE_COUNT - 1) ? state + 1 : 0;
}

/**********************************************************************************************************************
 * Function Name: initVideoSSInterrupts
 * Summary:
 *  Setting up VideoSS interrupts with respective handler and enabling them in NVIC.
 * Parameters:
 *  none
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void initVideoSSInterrupts(void)
{
    /* VideoSS interrupts configurations */
    const cy_stc_sysint_t IRQ_VIDEOSS_GFX2D_CFG =
    {
        .intrSrc  = ((NvicMux3_IRQn << CY_SYSINT_INTRSRC_MUXIRQ_SHIFT) | videoss_0_interrupt_gfx2d_IRQn),
        .intrPriority = 3UL
    };

    const cy_stc_sysint_t IRQ_VIDEOSS_VIDEOIO0_CFG =
    {
        .intrSrc  = ((NvicMux3_IRQn << CY_SYSINT_INTRSRC_MUXIRQ_SHIFT) | videoss_0_interrupt_videoio0_IRQn),
        .intrPriority = 3UL
    };
    
    const cy_stc_sysint_t IRQ_VIDEOSS_VIDEOIO1_CFG =
    {
        .intrSrc  = ((NvicMux3_IRQn << CY_SYSINT_INTRSRC_MUXIRQ_SHIFT) | videoss_0_interrupt_videoio1_IRQn),
        .intrPriority = 3UL
    };

    /* Initialize VideoSS interrupts */
    if (Cy_SysInt_Init(&IRQ_VIDEOSS_GFX2D_CFG, CyGfx_kInterruptHandlerGfx2d) != CY_SYSINT_SUCCESS)
    {
        CY_ASSERT(0);
    }
    if (Cy_SysInt_Init(&IRQ_VIDEOSS_VIDEOIO0_CFG, CyGfx_kInterruptHandlerVideoio0) != CY_SYSINT_SUCCESS)
    {
        CY_ASSERT(0);
    }
    if (Cy_SysInt_Init(&IRQ_VIDEOSS_VIDEOIO1_CFG, CyGfx_kInterruptHandlerVideoio1) != CY_SYSINT_SUCCESS)
    {
        CY_ASSERT(0);
    }
    
    /* Enable the corresponding NVIC interrupt */
    NVIC_EnableIRQ(NvicMux3_IRQn);
}

/**********************************************************************************************************************
 * Function Name: initDriverAndDisplay
 * Summary:
 *  Initializes the driver and a 800x480 display shown via FX3. Required timings are
 *  properly setup by adjusting PLLs. Driver and display need same timing information,
 *  thus both done in the same function.
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */

static CYGFX_ERROR initDriverAndDisplay(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    CYGFX_SYSINIT_INFO_S initInfo = CYGFX_SYS_INIT_INITIALIZER;
    CYGFX_DISP_PROPERTIES_S dispProps = CYGFX_DISP_PROPERTIES_INITIALIZER;
    CYGFX_U08 clockDivider;
    
    /* Use timing properties located in util library for 800x480 display */
    dispProps = s_panel_XXX_800_480;
    
    /* FX3 output is on display controller 1 */
    dispProps.outputController = CYGFX_DISP_CONTROLLER_1;
    
    /* FX3 RGB signals do not need to be remapped, thus don't use TCON */
    dispProps.pTconProps = NULL;
    dispProps.countTconProps = 0;
    
    /* Calculate PLL frequency based on pixel clock. PLL_1 is used for FX3 output */
    UTIL_SUCCESS(ret, utDispGetPll(dispProps.timing.pixelClock,
         dispProps.displayMode, &clockDivider, &initInfo.PllDsp1));
    UTIL_SUCCESS(ret, utDispEnablePll(initInfo.PllDsp1, dispProps.outputController));
    
    /* Init driver and reset memory manager */
    UTIL_SUCCESS(ret, CyGfx_SysInitializeDriver(&initInfo));
    UTIL_SUCCESS(ret, utMmanReset());
    
    /* Enable display */
    UTIL_SUCCESS(ret, CyGfx_DispOpenDisplay(&dispProps, &disp, NULL));
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: initContext
 * Summary:
 *  Initializes a context for the Blit Engine and sets origin of coordinate system
 *  to top-left of display.
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR initContext(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    UTIL_SUCCESS(ret, utPeGenContext(&ctx));
    
    /* Change origin of coordinate system to the top left point of display */
    UTIL_SUCCESS(ret, CyGfx_BeSetAttribute(ctx, CYGFX_BE_CTX_ATTR_ZERO_POINT, CYGFX_BE_ATTR_ZERO_TOP_LEFT));
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: initTaskInstrBuffer
 * Summary:
 *  Allocates memory for task instruction buffer and registers it to graphics driver.
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR initTaskInstrBuffer(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    taskInstrBuffer = utVideoAlloc(TASK_INSTR_BUFFER_SIZE, 32, NULL);
    CY_ASSERT(taskInstrBuffer != NULL);
    UTIL_SUCCESS(ret, CyGfx_BeSetTaskInstructionBuffer(CYGFX_BE_TASK_MEM_PRIO_1, 
        taskInstrBuffer, TASK_INSTR_BUFFER_SIZE));
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: initSync
 * Summary:
 *  Initializes all used sync objects.
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR initSync(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    UTIL_SUCCESS(ret, CyGfx_SyncReset(&db.sync));
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: initSurfaces
 * Summary:
 *  Initializes all surfaces (by allocating memory, loading bitmaps, etc.).
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR initSurfaces(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    /* Framebuffer 0 */
    UTIL_SUCCESS(ret, utSmGenSurfaceObjects(1, &db.surfFramebuffer[0]));
    UTIL_SUCCESS(ret, utSurfCreateBuffer(db.surfFramebuffer[0], DISPLAY_WIDTH, DISPLAY_HEIGHT,
         CYGFX_SM_FORMAT_R8G8B8));
    UTIL_SUCCESS(ret, CyGfx_BeBindSurface(ctx, CYGFX_BE_TARGET_STORE | CYGFX_BE_TARGET_DST, db.surfFramebuffer[0]));
    
    /* Framebuffer 1 */
    UTIL_SUCCESS(ret, utSmGenSurfaceObjects(1, &db.surfFramebuffer[1]));
    UTIL_SUCCESS(ret, utSurfCreateBuffer(db.surfFramebuffer[1], DISPLAY_WIDTH, DISPLAY_HEIGHT,
         CYGFX_SM_FORMAT_R8G8B8));
    
    /* Infineon Logo */
    UTIL_SUCCESS(ret, utSmGenSurfaceObjects(1, &surfIfx));
    UTIL_SUCCESS(ret, utSurfLoadBitmap(surfIfx, ifx_logo_color, false));
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: initWindows
 * Summary:
 *  Initializes all windows with respective properties.
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR initWindows(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    CYGFX_DISP_WINDOW_PROPERTIES_S winProps = CYGFX_DISP_WINDOW_PROPERTIES_INITIALIZER;
    
    winProps.width = WINDOW_WIDTH;
    winProps.height = WINDOW_HEIGHT;
    winProps.topLeftX = (DISPLAY_WIDTH - WINDOW_WIDTH) / 2.f;
    winProps.topLeftY = (DISPLAY_HEIGHT - WINDOW_HEIGHT) / 2.f;
    winProps.layerId = CYGFX_DISP_LAYER_0;
    UTIL_SUCCESS(ret, CyGfx_DispWinCreate(disp, &winProps, &db.win));
    UTIL_SUCCESS(ret, CyGfx_WinSetSurface(db.win, CYGFX_DISP_BUFF_TARGET_COLOR_BUFF, db.surfFramebuffer[0]));
    UTIL_SUCCESS(ret, CyGfx_WinCommit(db.win));
    UTIL_SUCCESS(ret, CyGfx_WinGetSync(db.win, &db.sync));
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: clearWindow
 * Summary:
 *  Clears the complete window by filling with a constant color (white).
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR clearWindow(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    UTIL_SUCCESS(ret, CyGfx_BeSetAttribute(ctx, CYGFX_BE_CTX_ATTR_COLOR, CYGFX_SM_COLOR_TO_RGBA(255, 255, 255, 255)));
    UTIL_SUCCESS(ret, CyGfx_BeFill(ctx, 0, 0, WINDOW_WIDTH, WINDOW_HEIGHT));
    
    return ret;   
}

/**********************************************************************************************************************
 * Function Name: renderTranslateScene
 * Summary:
 *  Scene demonstrating translation. Implements simple collision detection to the borders of the windows and bounces
 *  the logo off accordingly.
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR renderTranslateScene(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    Mat3x2 matTrans;
    static CYGFX_FLOAT transX = 0.f;
    static CYGFX_FLOAT transY = 0.f;

    static CYGFX_FLOAT velX = 3.f;
    static CYGFX_FLOAT velY = 1.5f;

    CYGFX_S32 symbol_width = utSurfWidth(surfIfx);
    CYGFX_S32 symbol_height = utSurfHeight(surfIfx);

    if (transX < 0)
    {
        transX = 0.f;
        velX = -velX;
    }

    if (transX > (WINDOW_WIDTH - symbol_width))
    {
        transX = WINDOW_WIDTH - symbol_width;
        velX = -velX;
    }

    if (transY < 0)
    {
        transY = 0.f;
        velY = -velY;
    }

    if (transY > (WINDOW_HEIGHT - symbol_height))
    {
        transY = WINDOW_HEIGHT - symbol_height;
        velY = -velY;
    }

    transX += velX;
    transY += velY;

    utMat3x2LoadIdentity(matTrans);
    utMat3x2Translate(matTrans, transX, transY);

    UTIL_SUCCESS(ret, CyGfx_BeBindSurface(ctx, CYGFX_BE_TARGET_SRC, surfIfx));
    UTIL_SUCCESS(ret, CyGfx_BeSetGeoMatrix(ctx, CYGFX_BE_TARGET_SRC, CYGFX_BE_GEO_MATRIX_FORMAT_3X2, matTrans));

    UTIL_SUCCESS(ret, CyGfx_BeBlt(ctx, 0.f, 0.f));
    
    return ret;   
}

/**********************************************************************************************************************
 * Function Name: renderScaleScene
 * Summary:
 *  Scene demonstrating scaling. Continuously enlarges and shrinks the logo. 
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR renderScaleScene(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    Mat3x2 matScale;
    static CYGFX_FLOAT scaleX = 0.1f;
    static CYGFX_FLOAT scaleY = 0.1f;

    static CYGFX_FLOAT velX = 0.01f;
    static CYGFX_FLOAT velY = 0.01f;

    if (scaleX > 5.f)
    {
        scaleX = 4.9f;
        velX = -velX;
    }

    if (scaleX < 0.f)
    {
        scaleX = 0.1f;
        velX = -velX;
    }

    if (scaleY > 5.f)
    {
        scaleY = 4.9f;
        velY = -velY;
    }

    if (scaleY < 0.f)
    {
        scaleY = 0.1f;
        velY = -velY;
    }

    scaleX += velX;
    scaleY += velY;

    CYGFX_FLOAT translateX = (CYGFX_FLOAT) WINDOW_WIDTH/2.f - scaleX*utSurfWidth(surfIfx)/2.f;
    CYGFX_FLOAT translateY = (CYGFX_FLOAT) WINDOW_HEIGHT/2.f - scaleY*utSurfHeight(surfIfx)/2.f;

    utMat3x2LoadIdentity(matScale);
    utMat3x2Translate(matScale, translateX, translateY);
    utMat3x2Scale(matScale, scaleX, scaleY);

    UTIL_SUCCESS(ret, CyGfx_BeBindSurface(ctx, CYGFX_BE_TARGET_SRC, surfIfx));
    UTIL_SUCCESS(ret, CyGfx_BeSetGeoMatrix(ctx, CYGFX_BE_TARGET_SRC, CYGFX_BE_GEO_MATRIX_FORMAT_3X2, matScale));

    UTIL_SUCCESS(ret, CyGfx_BeBlt(ctx, 0.f, 0.f));
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: renderRotateScene
 * Summary:
 *  Scene demonstrating rotation. Rotates multiple logos with varying speed, scales and locations at the same time. 
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR renderRotateScene(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    const CYGFX_FLOAT POS[10] = 
    { 
        10.f,   20.f,
        100.f,  200.f,
        400.f,  350.f,
        250.f,  100.f,
        500.f,  150.f
    };
    const CYGFX_FLOAT SCALES[5] = {1.f, 0.2f, 2.f, 0.6f, 1.2f};
    const CYGFX_FLOAT VEL_ROT [5] = {1.f, -5.f, 0.5f, -4.f, 3.f};
    static CYGFX_FLOAT rotations[5] = {15.f, 30.f, -20.f, 90.f, -33.f};
    Mat3x2 matRotate[5];

    UTIL_SUCCESS(ret, CyGfx_BeBindSurface(ctx, CYGFX_BE_TARGET_SRC, surfIfx));
    for (int i = 0; i < 5; ++i)
    {
        rotations[i] += VEL_ROT[i];
        utMat3x2LoadIdentity(matRotate[i]);
        utMat3x2Translate(matRotate[i], POS[2*i], POS[2*i+1]);
        utMat3x2Rot(matRotate[i], rotations[i]);
        utMat3x2Translate(matRotate[i], -SCALES[i]*utSurfWidth(surfIfx)/2.f, -SCALES[i]*utSurfHeight(surfIfx)/2.f);
        utMat3x2Scale(matRotate[i], SCALES[i], SCALES[i]);

        UTIL_SUCCESS(ret, CyGfx_BeSetGeoMatrix(ctx, CYGFX_BE_TARGET_SRC,
             CYGFX_BE_GEO_MATRIX_FORMAT_3X2, matRotate[i]));
        UTIL_SUCCESS(ret, CyGfx_BeBlt(ctx, 0.f, 0.f));
    }
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: renderShearScene
 * Summary:
 *  Scene demonstrating shearing. Shears the logo continuously in both x directions.
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR renderShearScene(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    /** Matrix with three columns and two rows for affine geometry operations.
    If m is a Mat3x2 matrix type and x,y in an input vector, the resulting vector is:
    / m[0] m[2] m[4] \ * / x \ =  / (m[0] * x) + (m[2] * y) + m[4] \
    \ m[1] m[3] m[5] /   \ y /    \ (m[1] * x) + (m[3] * y) + m[5] /
    */
    static CYGFX_FLOAT shearX = 0.5f;
    static CYGFX_FLOAT shearY = 0.f;
    static CYGFX_FLOAT velX = 0.01f;

    if (shearX > 1.f)
    {
        shearX = 0.99f;
        velX = -velX;
    }

    if (shearX < -1.f)
    {
        shearX = -0.99f;
        velX = -velX;
    }

    shearX += velX;

    Mat3x2 mat_shear = 
    {
        1.f, shearY, shearX,
        1.f, 0.f, 0.f
    };

    UTIL_SUCCESS(ret, CyGfx_BeBindSurface(ctx, CYGFX_BE_TARGET_SRC, surfIfx));
    UTIL_SUCCESS(ret, CyGfx_BeSetGeoMatrix(ctx, CYGFX_BE_TARGET_SRC, CYGFX_BE_GEO_MATRIX_FORMAT_3X2, mat_shear));

    UTIL_SUCCESS(ret, CyGfx_BeBlt(ctx, WINDOW_WIDTH/2.f - utSurfWidth(surfIfx)/2.f,
         WINDOW_HEIGHT/2.f - utSurfHeight(surfIfx)/2.f));
    
    return ret;
}

/**********************************************************************************************************************
 * Function Name: renderPerspectiveScene
 * Summary:
 *  Scene demonstrating perspective. Rotates the logo around x-axis if we assume a three-dimensional coordinate system.
 *  Final matrix is calculated with the help of a 4x4 projection matrix.
 * Parameters:
 *  none
 * Return:
 *  CYGFX_ERROR error code if issue, else CYGFX_OK
 **********************************************************************************************************************
 */
static CYGFX_ERROR renderPerspectiveScene(void)
{
    CYGFX_ERROR ret = CYGFX_OK;
    
    Mat4x4 matView;
    Mat4x4 matRotation;
    Mat4x4 matProjection;
    Mat4x4 matViewport;
    Mat4x4 matFinal;

    const CYGFX_FLOAT FOV = 45.f;
    const CYGFX_FLOAT ASPECT = 1.f;
    const CYGFX_FLOAT NEAR_PLANE = 0.1f;
    const CYGFX_FLOAT FAR_PLANE = 100.f;
    const CYGFX_FLOAT VEL_ROT = 1.f;
    
    static CYGFX_FLOAT rotation = 30.f;

    rotation += VEL_ROT;

    /* Calculate view matrix, which will prepare translation and shifting for perspective */
    utMat4x4LoadIdentity(matView);
    utMat4x4Translate(matView, -1.f, -1.f, 0.f);
    utMat4x4Scale(matView, 2.f / utSurfWidth(surfIfx), 2.f / utSurfHeight(surfIfx), 1.f);

    /* Do something dynamic on object, in this case rotate it */
    utMat4x4LoadIdentity(matRotation);
    utMat4x4RotX(matRotation, rotation);

    /* Calculate projection matrix, which will generate perspective */
    utMat4x4LoadIdentity(matProjection);
    utMat4x4Perspective(matProjection, FOV, ASPECT, NEAR_PLANE, FAR_PLANE);
    utMat4x4Translate(matProjection, 0.f, 0.f, -6.f);

    /* Calculate viewport matrix, which will put the object back to the screen (after perspective) */
    utMat4x4LoadIdentity(matViewport);
    utMat4x4Translate(matViewport, WINDOW_WIDTH/2.f, WINDOW_HEIGHT/2.f, 0.f);
    utMat4x4Scale(matViewport, 1.5f*utSurfWidth(surfIfx), 1.5f*utSurfHeight(surfIfx), 1.f);

    /* Combine all matrices (pay attention to correct order of multiplications!) */
    utMat4x4LoadIdentity(matFinal);
    utMat4x4Multiply(matFinal, matFinal, matViewport);
    utMat4x4Multiply(matFinal, matFinal, matProjection);
    utMat4x4Multiply(matFinal, matFinal, matRotation);
    utMat4x4Multiply(matFinal, matFinal, matView);

    /* Transform to 3x3 matrix (perspective divide) */
    Mat3x3 matApply;
    utMat4x4ToMat3x3(matFinal, matApply);

    UTIL_SUCCESS(ret, CyGfx_BeBindSurface(ctx, CYGFX_BE_TARGET_SRC, surfIfx));
    UTIL_SUCCESS(ret, CyGfx_BeSetGeoMatrix(ctx, CYGFX_BE_TARGET_SRC, CYGFX_BE_GEO_MATRIX_FORMAT_3X3, matApply));

    UTIL_SUCCESS(ret, CyGfx_BeBlt(ctx, 0.f, 0.f));
    
    return ret;
}
